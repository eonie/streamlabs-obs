import { Observable } from 'rxjs/Observable';
import { from } from 'rxjs/observable/from';
import { empty } from 'rxjs/observable/empty';
import 'rxjs/add/observable/fromPromise';
import { handleErrors } from '../../../util/requests';
import { contramap, ordString } from 'fp-ts/lib/Ord';
import { sortBy1 } from 'fp-ts/lib/Array';
import { compose } from 'fp-ts/lib/function';
import { fromNullable } from 'fp-ts/lib/Option';
import { TwitchPagination } from './pagination';
import { fromPromise } from 'rxjs/observable/fromPromise';
import { concat, mergeMap } from 'rxjs/operators';

/**
 * A tag on Twitch that could be assigned to a Stream.
 */
export type TwitchTag = {
  tag_id: string;
  /**
   * `true` if the tag is autogenerated.
   */
  is_auto: boolean;
  localization_names: {
    /**
     * Keys are locale names, in underscore (e.g. en-us). Values are the translations.
     */
    [x: string]: string;
  };
  localization_descriptions: {
    [x: string]: string;
  };
};

/**
 * TwichTag with a label in the user's locale or en-US as fallback
 */
export type TwitchTagWithLabel = TwitchTag & { name: string };

/**
 * Response coming from Twitch from the Tags endpoint.
 */
type TwitchTagsResponse = {
  data: Array<TwitchTag>;
  pagination: TwitchPagination;
};

/**
 * Intermediate representation of a Twitch tag response so
 * we can request subsequent pages of tags.
 */
interface PaginatedResponse {
  items: Array<TwitchTag>;
  cursor: string;
}

const requestTags = (headers: Headers, cursor: string = ''): Observable<PaginatedResponse> =>
  fromPromise(
    fetch(`https://api.twitch.tv/helix/tags/streams?first=100&after=${cursor}`, { headers })
      .then(handleErrors)
      .then<TwitchTagsResponse>(response => response.json())
      .then(response => ({ items: response.data, cursor: response.pagination.cursor }))
  );

/**
 * Fetch all available tags that Twitch provides that are not
 * automatically generated. This will use the provided pagination
 * to request the whole dataset of tags.
 *
 *
 * @param headers Headers including OAuth Token and App ID
 */
// FIXME: Twitch Pagination seems broken regarding cursor
export const getAllTags = async (headers: Headers): Promise<TwitchTag[]> => {
  return requestTags(headers)
    .pipe(
      mergeMap(
        ({ items, cursor }): any => {
          const items$ = from(items);
          const next$ = cursor ? requestTags(headers, cursor) : empty<PaginatedResponse>();
          return concat(items$, next$);
        }
      )
    )
    .toPromise() as Promise<TwitchTag[]>;
};

const getLabelFor = (tag: TwitchTag, locale: string): string =>
  tag.localization_names[locale.toLowerCase()] || tag.localization_names['en-us'];

const assignLabels = (locale: string) => (tags: Array<TwitchTag>): Array<TwitchTagWithLabel> =>
  tags.map(tag => ({
    ...tag,
    name: getLabelFor(tag, locale)
  }));

const byName = contramap((tag: TwitchTagWithLabel) => tag.name, ordString);
const sortByName = sortBy1(byName, []);

export const prepareOptions = (locale: string, tags: Array<TwitchTag> | undefined): Array<TwitchTagWithLabel> =>
  fromNullable(tags)
    .map(
      compose(
        sortByName,
        assignLabels(locale)
      )
    )
    .getOrElse([]);

export const updateTags = (headers: Headers) => (tags: Array<TwitchTagWithLabel>) => (streamId: string) => {
  const toAdd = tags;

  // TODO: how to track removals if we can't even get the active list w/o going live
  const toRemove: Array<TwitchTagWithLabel> = [];

  const params = {
    ...addParam('add', toAdd),
    ...addParam('remove', toRemove)
  };

  return fetch(
    new Request(`https://api.twitch.tv/helix/tags/streams?broadcaster_id=${streamId}`, {
      headers,
      method: 'PUT',
      body: JSON.stringify(params)
    })
  );
};

/**
 * Add a parameter, either "add" or "remove" with tag IDs separated by commas
 */
const addParam = (op: 'add' | 'remove', tags: Array<TwitchTagWithLabel>) => {
  if (!tags.length) {
    return {};
  }

  return { [op]: tags.map(tag => tag.tag_id).join(',') };
};
